-- Use Atom plugin command below or paste decker.ttslua code there
#include Decker

-- THE UTILITY ZOAN
function trim(s)
   return s:match'^%s*(.*%S)' or ''
end

-- Check if string begins with the argument (no regex)
string.beginswith = function(str, prefix)
    return (str:sub(1, prefix:len()) == prefix)
end
string.startswith = string.beginswith

-- Global deck of all cards in Classic (1x each), in correct order so we can use index order as ID
-- Turns out the deck is too massive to persist this way!
classicDeck = {}

-- Ok, let's just save the assets and rebuild the deck on load. np, right?
allAssets = {}

-- args is a table of strings
function echo(args)
    for _, v in pairs(args) do print(v) end
end

function makeAssets(args)
    -- Width or height must be less than 10k pixels
    local width = 10
    local height = 7
    local cardBack = 'https://drive.google.com/uc?export=download&id=' .. '1FJFIEYguHCH7NiAnXocjocWgytFgeCWU'

    local assets = {}
    for page, fileid in ipairs(args) do
        -- local page = tonumber(page)
        local cardFaces = 'https://drive.google.com/uc?export=download&id=' .. fileid
        local pageAsset = Decker.Asset(cardFaces, cardBack, {width = width, height = height, name = "classic page "..page})
        assets[page] = pageAsset
    end
    return assets
end

function makeClassic()
    local allCards = {}
    for page, asset in ipairs(allAssets) do
        local pageDeck = Decker.AssetDeck(asset, nil)
        for idx, _ in pairs(pageDeck.data.ContainedObjects) do
            local card = pageDeck:cardAt(idx)
            allCards[#allCards+1] = card
        end
    end
    return Decker.Deck(allCards, {})
end

function updateClassic(args)
    print("Updating the assets...")
    allAssets = makeAssets(args)

    print("Updating Classic Deck...")
    classicDeck = makeClassic()

    print("Spawning Classic Deck for convenience (use "..chatCommandPrefix.."spawn.classic to just get fresh copies)")
    spawnClassic({})
end

function autoUpdateClassic(args)
    local url = "https://skypirate-deckgen.herokuapp.com/api/card_sheets"
    function callback(webReturn)
        local parsed = JSON.decode(webReturn.text)
        for page, fid in ipairs(parsed) do print("Page "..page..": "..fid) end
        updateClassic(parsed)
    end

    WebRequest.get(url, callback)
end

function spawnClassic(args)
    classicDeck:spawn({position = {0,0,0}, rotation = {0, 0, 180}})
end


-- Make a Decker.Deck by pulling cards from the Classic deck based on the decklist
function buildDeck(decklist, options)
    local cards = {}
    local options = options or {}
    for idx, entry in ipairs(decklist) do
      for i=1,entry.qty do
        cards[#cards+1] = classicDeck:cardAt(tonumber(entry.id)+1):setCommon(options)
      end
    end

    return Decker.Deck(cards, options)
end

-- Given a deck name, request JSON and spawn the deck based on that JSON
function spawnDeck(args)
    local deckFileId = args[1]
    local url = "https://skypirate-deckgen.herokuapp.com/api/decks/"..deckFileId

    function callback(webReturn)
        local parsed = JSON.decode(webReturn.text)
        local newDeck = buildDeck(parsed["cards"], {name = parsed["name"]})
        print(parsed["name"].." fetched and built. Spawning...")
        newDeck:spawn({position = {0, 0, 0}})
        print(parsed["name"].." spawned!")
    end

    WebRequest.get(url, callback)
end

function help(args)
    print("HELP:")
    for cmdName,cmd in pairs(chatCommands) do
        print("---")
        print(chatCommandPrefix..cmdName.." "..cmd.description)
    end
end

-- Event Handlers
chatCommandPrefix = "."
chatCommandArgDelimiter = " "
chatCommands =  {
    ["spawn.classic"] = { func = spawnClassic, description = "-> Spawns a Classic deck." },
    ["spawn.deck"] = { func = spawnDeck, description = "DeckId".." -> Spawns a deck based on deck id from DeckGen server." },
    ["update.manual"] = { func = updateClassic, description = "pageOneFileId"..chatCommandArgDelimiter.."pageTwoFileId -> Update cached Classic set." },
    ["update"] = { func = autoUpdateClassic, description = "-> Update cached Classic set based on skypirate-deckgen.herokuapp.com/api/classic_sheets."},
    ["help"] = { func = help, description = "-> This list of descriptions." },
    ["echo"] = { func = echo, description = "hi"..chatCommandArgDelimiter.."you".." -> hi\nyou" },
}

function onChat(msg)
    -- parse command if it begins with control char
    if(string.beginswith(msg, chatCommandPrefix)) then
        -- extract the command
        local cmdName, argString = msg:match("%"..chatCommandPrefix.."([^ ]*)[ ]?(.*)")

        -- get the function to run
        local command = chatCommands[cmdName]

        -- break the args (on comma) into a table of individual args
        local args = {}
        for word in argString:gmatch("[^%"..chatCommandArgDelimiter.."]+") do args[#args+1] = word end

        -- run the function
        if(command.func) then
            command.func(args)
        else
            print("The command "..cmd.." is not recognized")
        end
    end
end

function onSave()
    local saved_data = JSON.encode(allAssets)
    return saved_data
end

function onLoad(saved_data)
    -- Load the persisted assets
    if saved_data ~= "" then
        print("Classic assets loaded from save.")
        local loaded_data = JSON.decode(saved_data)
        print("Classic assets parsed from JSON and set.")
        allAssets = loaded_data

        classicDeck = makeClassic()
        print("Classic deck set. Mod ready!")
    else
        print("Classic assets were not found in save. Run "..chatCommandPrefix.."update")
        allAssets = {}
    end
    broadcastToAll('Use commands in chat. Use '..chatCommandPrefix..'help to see options.', {1, 1, 1})
end
